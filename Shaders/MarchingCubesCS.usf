#pragma once

#include "MarchingCubeCommons.ush"
#include "/Engine/Public/Platform.ush"
#include "VoxelVDBCommons.ush"

/**
 * Thanks 龚大.
 * https://github.com/gongminmin/AIHoloImager/tree/main
 */

#if !defined(VOXEL_WRITABLE_CUBE_INDEX_OFFSETS)
#	define VOXEL_WRITABLE_CUBE_INDEX_OFFSETS 0
#endif

cbuffer MarchingCubeParameters
{
	/// Assume dimension X, Y, Z is the same as VoxelSize
	uint VoxelSize;

	/// Total number of cubes
	uint TotalCubes;

	/// The SDF (Level Set in nanovdb) value smaller than this value will be treated as inside the surface
	float SurfaceIsoValue;
};

/// Nanovdb Level Set Buffer
pnanovdb_buf_t SrcVoxelData;

/// Vertex Buffer Layout
/// =================================
/// | float3 | float(packed normal) |
/// =================================
/// Stride = 4 * sizeof(float)
RWBuffer<float> OutVertexBuffer;
/// Index Buffer Layout
/// ============================
/// | uint32 | uint32 | uint32 |
/// ============================
RWBuffer<uint> OutIndexBuffer;

/// Atomic counter
/// Size >= 3
RWBuffer<uint> Counter;

/// Cube index offset of specified ThreadID.x
/// It stores the execution order of the threads that has valid cube index.
/// Also means the prefix sum of the valid cases.
RWBuffer<uint> OutCubeIndexOffsets;
Buffer<uint> InCubeIndexOffsets;

/// Mapping from "prefix sum of valid cases" to "linear index"
RWBuffer<uint> OutNonEmptyCubeLinearId;
Buffer<uint> InNonEmptyCubeLinearId;

/// Cube index of a cube
RWBuffer<uint> OutNonEmptyCubeIndex;
Buffer<uint> InNonEmptyCubeIndex;

/// Indicate the base address when write to VBO/IBO.
RWBuffer<uint2> OutVertexIndexOffset;
Buffer<uint2> InVertexIndexOffset;

struct FVoxelVdbValueWithGradient
{
	float3 Gradient;
	float Value;
};

inline uint GetIndexByPoint(uint3 Point)
{
	return Point.x + Point.y * 65535U;
}

inline uint3 GetIndexSpaceCoordByLinearId(uint Index)
{
	const uint SizeXY = floor(Index / VoxelSize);
	const uint IndexZ = Index - (SizeXY * VoxelSize); // Rest i of the cube volume
	const uint IndexX = floor(SizeXY / VoxelSize);
	const uint IndexY = SizeXY - (IndexX * VoxelSize);
	return uint3(IndexX, IndexY, IndexZ);
}

inline uint3 SafeIndexCoord(uint3 IndexSpaceCoord)
{
	return min(IndexSpaceCoord, VoxelSize - 1);
}

inline float SampleVoxelPoint(uint3 IndexSpaceCoord, in out FVoxelVdbSampler Sampler)
{
	return ReadVdbValue(SafeIndexCoord(IndexSpaceCoord), Sampler.Buffer, Sampler.GridType, Sampler.Accessor);
}

FVoxelVdbValueWithGradient SampleVoxelPointWithGradientSafe(uint3 IndexSpaceCoord, in out FVoxelVdbSampler Sampler)
{
	uint3 IndexPrevious = max(IndexSpaceCoord, 1) - 1;
	uint3 IndexNext = min(IndexSpaceCoord + 1, float3(VoxelSize, VoxelSize, VoxelSize) - 1);
	uint3 Index = IndexSpaceCoord;

	FVoxelVdbValueWithGradient Result;
	Result.Value = SampleVoxelPoint(IndexSpaceCoord, Sampler);

	float ValueNextX = SampleVoxelPoint(float3(IndexNext.x, Index.y, Index.z), Sampler);
	float ValuePrevX = SampleVoxelPoint(float3(IndexPrevious.x, Index.y, Index.z), Sampler);
	
	float ValueNextY = SampleVoxelPoint(float3(Index.x, IndexNext.y, Index.z), Sampler);
	float ValuePrevY = SampleVoxelPoint(float3(Index.x, IndexPrevious.y, Index.z), Sampler);
	
	float ValueNextZ = SampleVoxelPoint(float3(Index.x, Index.y, IndexNext.z), Sampler);
	float ValuePrevZ = SampleVoxelPoint(float3(Index.x, Index.y, IndexPrevious.z), Sampler);

	Result.Gradient = float3(ValuePrevX - ValueNextX, ValuePrevY - ValueNextY, ValuePrevZ - ValueNextZ);

	return Result;
}

inline uint GetAtomicCounter(uint Index, uint ValueToAdd)
{
	uint Value;
	InterlockedAdd(Counter[Index], ValueToAdd, Value);
	return Value;
}

inline uint CalcCubeIndex(uint3 IndexCoord, in out FVoxelVdbSampler Sampler)
{
	float Samples[8] = {
		SampleVoxelPoint(IndexCoord + uint3(0, 0, 0), Sampler),
		SampleVoxelPoint(IndexCoord + uint3(1, 0, 0), Sampler),
		SampleVoxelPoint(IndexCoord + uint3(1, 1, 0), Sampler),
		SampleVoxelPoint(IndexCoord + uint3(0, 1, 0), Sampler),
		SampleVoxelPoint(IndexCoord + uint3(0, 0, 1), Sampler),
		SampleVoxelPoint(IndexCoord + uint3(1, 0, 1), Sampler),
		SampleVoxelPoint(IndexCoord + uint3(1, 1, 1), Sampler),
		SampleVoxelPoint(IndexCoord + uint3(0, 1, 1), Sampler),
	};

	uint CubeIndex = 0;
	for (uint i = 0; i < sizeof(Samples) / sizeof(Samples[0]); ++i)
	{
		if (Samples[i] <= SurfaceIsoValue)
		{
			CubeIndex |= 1U << i;
		}
	}

	return CubeIndex;
}

#define WORKGROUP_SIZE_X 64
#define WORKGROUP_SIZE_Y 1
#define WORKGROUP_SIZE_Z 1

[numthreads(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, WORKGROUP_SIZE_Z)]
void CalcCubeIndexCS(uint3 ThreadID: SV_DispatchThreadID)
{
	// Boundary check to prevent dirty result.
	const uint LinearIndex = GetIndexByPoint(ThreadID);
	BRANCH if (LinearIndex >= TotalCubes)
	{
		return;
	}
	
	// Create Sampler
	FVoxelVdbSampler Sampler = CreateVdbSampler(SrcVoxelData);

	// Get coordinate from ThreadID.x
	const uint3 Coord = GetIndexSpaceCoordByLinearId(LinearIndex);

	// Cube Index
	const uint CubeIndex = CalcCubeIndex(Coord, Sampler);

	// Filtering out empty cube to prevent an unnecessary atomic operation.
	BRANCH
	if (EdgeTable[CubeIndex] != 0)
	{
		uint Idx = GetAtomicCounter(0, 1U);
		OutCubeIndexOffsets[LinearIndex] = Idx;
	}
	else
	{
		OutCubeIndexOffsets[LinearIndex] = ~0U;
	}
}

[numthreads(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, WORKGROUP_SIZE_Z)]
void CalcVertexAndIndexPrefixSumCS(uint3 ThreadID: SV_DispatchThreadID)
{
	// Boundary check
	const uint LinearIndex = GetIndexByPoint(ThreadID);
	BRANCH if (LinearIndex >= TotalCubes)
	{
		return;
	}

	const uint CubeOffset = InCubeIndexOffsets[LinearIndex];
	BRANCH if (CubeOffset == ~0U)
	{
		return;
	}

	// Filter out empty cases and save the relationship.
	OutNonEmptyCubeLinearId[CubeOffset] = LinearIndex;

	// Save the cube index of current cube
	FVoxelVdbSampler Sampler = CreateVdbSampler(SrcVoxelData);
	uint3 Coord = GetIndexSpaceCoordByLinearId(LinearIndex);
	uint CubeIndex = CalcCubeIndex(Coord, Sampler);
	OutNonEmptyCubeIndex[CubeOffset] = CubeIndex;

	// Calc there is how many indices in current cube
	const uint NumIndices = TriangleNumTable[CubeIndex];

	// How many vertices will be produced in this cube
	uint Edges = EdgeTable[CubeIndex];
	uint NumVertices = 0;
	BRANCH if (Edges != 0)
	{
		for (uint i = 0; i < sizeof(OwnedEdge) / sizeof(OwnedEdge[0]); ++i)
		{
			const uint Edge = OwnedEdge[i];
			if (Edges & (1U << Edge))
			{
				++NumVertices;
			}
		}
	}

	// Use atomic counter to calculate the prefix sum
	uint VertexIndex = GetAtomicCounter(1, NumVertices);
	uint IndexIndex = GetAtomicCounter(2, NumIndices);
	OutVertexIndexOffset[CubeOffset] = uint2(VertexIndex, IndexIndex);
}


// Old BF implementation
#if 0
void WriteTriangle(float3 Pos1, float3 Pos2, float3 Pos3)
{
	uint Counter;
	InterlockedAdd(TriangleCounter, 1U, Counter);
	GroupMemoryBarrierWithGroupSync();

	uint VertexIndexStart = Counter * 9;
	
	OutVertexBuffer[VertexIndexStart + 0] = Pos1.x;
	OutVertexBuffer[VertexIndexStart + 1] = Pos1.y;
	OutVertexBuffer[VertexIndexStart + 2] = Pos1.z;
	OutVertexBuffer[VertexIndexStart + 3] = Pos2.x;
	OutVertexBuffer[VertexIndexStart + 4] = Pos2.y;
	OutVertexBuffer[VertexIndexStart + 5] = Pos2.z;
	OutVertexBuffer[VertexIndexStart + 6] = Pos3.x;
	OutVertexBuffer[VertexIndexStart + 7] = Pos3.y;
	OutVertexBuffer[VertexIndexStart + 8] = Pos3.z;

	uint TriangleIndexStart = Counter * 3;
	OutIndexBuffer[TriangleIndexStart + 0] = TriangleIndexStart + 0;
	OutIndexBuffer[TriangleIndexStart + 1] = TriangleIndexStart + 1;
	OutIndexBuffer[TriangleIndexStart + 2] = TriangleIndexStart + 2;
}

[numthreads(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, WORKGROUP_SIZE_Z)]
void MainCS(uint3 ThreadID: SV_DispatchThreadID)
{
	// Boundary check to prevent dirty result.
	if (any(ThreadID + 1 >= float3(DimensionX, DimensionY, DimensionZ))) return;
	
	const uint LinearIndex = GetIndexByPoint(ThreadID);
	
	// Initialize current thread
	if (LinearIndex == 0U)
	{
		TriangleCounter = 0U;
	}
	GroupMemoryBarrierWithGroupSync();

	// Create Sampler
	FVoxelVdbSampler Sampler = CreateVdbSampler(SrcVoxelData);
	
	// Sample points
	FVoxelVdbValueWithGradient Samples[8];
	for (uint i = 0; i < 8; ++i)
	{
		Samples[i] = SampleVoxelPointWithGradient(ThreadID + MCCubeVertex(i), Sampler);
	}

	// Cube setup
	uint CubeSetup = 0;
	for (uint i = 0; i < 8; ++i)
	{
		CubeSetup |= (Samples[i].Value < SurfaceIsoValue) << i;
	}

	// There is no triangle will be generated in these two setups
	if (CubeSetup == 0 || CubeSetup == 255) return;

	// Lerp points to get intersection point on the edge
	float3 Vertices[12];
	float3 Normals[12];
	for (uint i = 0; i < 12; ++i)
	{
		uint2 Pair = uint2(EdgeVertexIndices[i][0], EdgeVertexIndices[i][1]);
		FVoxelVdbValueWithGradient Sample1 = Samples[Pair.x];
		FVoxelVdbValueWithGradient Sample2 = Samples[Pair.y];
		float3 VertexIndexPos1 = ThreadID + MCCubeVertex(Pair.x);
		float3 VertexIndexPos2 = ThreadID + MCCubeVertex(Pair.y);
		float InterpretationAlpha = (SurfaceIsoValue - Sample1.Value) / (Sample2.Value - Sample1.Value);
		Vertices[i] = lerp(VertexIndexPos1, VertexIndexPos2, InterpretationAlpha);
		Normals[i] = -normalize(lerp(Sample1.Gradient, Sample2.Gradient, InterpretationAlpha));
	}

	// Write triangles
	uint Triangles[16] = TriangleTable[CubeSetup];
	// Only 5 triangles at max, per cube
	for (uint i = 0; i < 5; ++i)
	{
		uint StripIndexStart = i * 3;
		// TODO: this might be optimized using vertex count table?
		if (Triangles[StripIndexStart] == 255U) break;

		for (int j = 0; j < 3; ++j)
		{
			float3 Pos1 = Vertices[Triangles[StripIndexStart + j + 0]];
			float3 Pos2 = Vertices[Triangles[StripIndexStart + j + 1]];
			float3 Pos3 = Vertices[Triangles[StripIndexStart + j + 2]];
			WriteTriangle(Pos1, Pos2, Pos3);
		}
	}
}
#endif
